/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */
package org.opensearch.index.store.cipher;

import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Provider;
import java.util.Arrays;
import java.util.Optional;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;

import org.opensearch.index.store.footer.EncryptionFooter;
import org.opensearch.index.store.footer.EncryptionMetadataTrailer;
import org.opensearch.index.store.key.HkdfKeyDerivation;

/**
 * Factory utility for creating and initializing Cipher instances
 *
 * This class is tailored for symmetric encryption modes like AES-CTR,
 * where a block counter is appended to the IV.
 *
 * @opensearch.internal
 */
public class AesCipherFactory {

    /**
     * Private constructor to prevent instantiation of utility class.
     */
    private AesCipherFactory() {}

    /** AES block size in bytes. Required for counter calculations. */
    public static final int AES_BLOCK_SIZE_BYTES = 16;

    /** Number of bytes used for the counter in the IV (last 4 bytes). */
    public static final int COUNTER_SIZE_BYTES = 4;

    /** Total IV array length (typically 16 bytes for AES). */
    public static final int IV_ARRAY_LENGTH = 16;

    /** The algorrithm. */
    public static final String ALGORITHM = "AES";

    /**
     * Returns a new Cipher instance configured for AES/CTR/NoPadding using the given provider.
     *
     * @param provider The JCE provider to use (e.g., SunJCE, BouncyCastle)
     * @return A configured {@link Cipher} instance
     * @throws RuntimeException If the algorithm or padding is not supported
     */
    public static Cipher getCipher(Provider provider) {
        try {
            return Cipher.getInstance("AES/CTR/NoPadding", provider);
        } catch (NoSuchPaddingException | NoSuchAlgorithmException e) {
            throw new RuntimeException("Failed to get cipher instance", e);
        }
    }

    /**
     * Thread-local cipher pool for AES/CTR/NoPadding operations using SunJCE provider.
     * Each thread gets its own cipher instance to avoid synchronization overhead.
     */
    public static final ThreadLocal<Cipher> CIPHER_POOL = ThreadLocal.withInitial(() -> {
        try {
            return Cipher.getInstance("AES/CTR/NoPadding", "SunJCE");
        } catch (NoSuchAlgorithmException | NoSuchProviderException | NoSuchPaddingException e) {
            throw new RuntimeException(e);
        }
    });

    /**
     * Computes an offset-adjusted IV for CTR mode decryption at a specific file position.
     * This allows seeking into an encrypted stream without re-processing prior blocks.
     *
     * <p>The method calculates which AES block corresponds to the given byte offset and updates
     * the last 4 bytes of the IV with a block counter value. The counter is incremented by 2
     * to maintain compatibility with GCM mode counter semantics, where:
     * <ul>
     * <li>Counter 0: Reserved for GCM internal use</li>
     * <li>Counter 1: Used for authentication data processing</li>
     * <li>Counter 2+: Used for actual data block encryption</li>
     * </ul>
     *
     * <p>This ensures that CTR mode IVs generated by this method can be safely used in mixed
     * environments where both CTR and GCM modes might be employed, preventing counter collision
     * and maintaining cryptographic security.
     *
     * @param baseIV the base initialization vector (typically 16 bytes)
     * @param offset the byte offset in the file/stream to compute the IV for
     * @return a new IV with the counter field adjusted for the specified offset
     * @throws IllegalArgumentException if baseIV is null or has invalid length
     */
    public static byte[] computeOffsetIVForAesGcmEncrypted(byte[] baseIV, long offset) {
        byte[] ivCopy = Arrays.copyOf(baseIV, baseIV.length);
        int blockOffset = (int) (offset / AesCipherFactory.AES_BLOCK_SIZE_BYTES);

        // Add 2 for GCM compatibility: counter 0 (reserved) + counter 1 (auth) + data counters start at 2
        blockOffset += 2;

        // Set the 4-byte counter in big-endian format (last 4 bytes of IV)
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 1] = (byte) blockOffset;
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 2] = (byte) (blockOffset >>> 8);
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 3] = (byte) (blockOffset >>> 16);
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 4] = (byte) (blockOffset >>> 24);

        return ivCopy;
    }

    /**
     * Computes an offset-adjusted IV for pure CTR mode encryption/decryption at a specific file position.
     * This method generates IVs for data that was originally encrypted using standard CTR mode without
     * GCM compatibility adjustments.
     *
     * <p>The method calculates which AES block corresponds to the given byte offset and updates
     * the last 4 bytes of the IV with the exact block counter value (starting from 0). This is used
     * for decrypting data that was encrypted with standard CTR mode where counters begin at 0.
     *
     * @param baseIV the base initialization vector (typically 16 bytes)
     * @param offset the byte offset in the file/stream to compute the IV for
     * @return a new IV with the counter field adjusted for the specified offset (starting from counter 0)
     * @throws IllegalArgumentException if baseIV is null or has invalid length
     */
    public static byte[] computeOffsetIVForAesCtrEncrypted(byte[] baseIV, long offset) {
        byte[] ivCopy = Arrays.copyOf(baseIV, baseIV.length);
        int blockOffset = (int) (offset / AesCipherFactory.AES_BLOCK_SIZE_BYTES);

        // Set the 4-byte counter in big-endian format (last 4 bytes of IV)
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 1] = (byte) blockOffset;
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 2] = (byte) (blockOffset >>> 8);
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 3] = (byte) (blockOffset >>> 16);
        ivCopy[AesCipherFactory.IV_ARRAY_LENGTH - 4] = (byte) (blockOffset >>> 24);

        return ivCopy;
    }
    
    /**
     * Compute frame-specific IV for large file encryption
     *
     * @param directoryKey      the directory's master key (32 bytes)
     * @param messageId         the file's unique MessageId (16 bytes)
     * @param frameNumber       the frame number (0-based)
     * @param offsetWithinFrame the byte offset within the frame
     * @param filePath
     * @return frame-specific IV for encryption/decryption
     */
    public static byte[] computeFrameIV(byte[] directoryKey, byte[] messageId, int frameNumber, long offsetWithinFrame, String filePath) {
        if (messageId.length != 16) {
            throw new IllegalArgumentException("MessageId must be 16 bytes");
        }
        if (frameNumber < 0 || frameNumber >= EncryptionMetadataTrailer.MAX_FRAMES_PER_FILE) {
            throw new IllegalArgumentException("Invalid frame number: " + frameNumber);
        }

        EncryptionCache encryptionCache = EncryptionCache.getInstance();
        byte[] frameBaseIV;
        
        // Try to get from footer cache first
        EncryptionFooter footer = encryptionCache.getFooter(filePath);
        if (footer != null) {
            Optional<byte[]> cachedIV = footer.getFrameIV(frameNumber);
            if (cachedIV.isPresent()) {
                frameBaseIV = cachedIV.get();
            } else {
                frameBaseIV = deriveAndStoreInFooter(directoryKey, messageId, frameNumber, footer);
            }
        } else {
            // Fallback to old cache mechanism
            frameBaseIV = encryptionCache.getFrameIv(filePath, frameNumber);
            if (frameBaseIV == null) {
                String frameContext = EncryptionMetadataTrailer.FRAME_CONTEXT_PREFIX + frameNumber;
                frameBaseIV = HkdfKeyDerivation.deriveKey(directoryKey, messageId, frameContext, 16);
                encryptionCache.putFrameIv(filePath, frameNumber, frameBaseIV);
            }
        }
        
        // Modify last 4 bytes for block counter within frame
        byte[] frameIV = new byte[16];
        System.arraycopy(frameBaseIV, 0, frameIV, 0, 16);
        int blockOffset = (int) (offsetWithinFrame / AES_BLOCK_SIZE_BYTES);

        // Add 2 for GCM compatibility: counter 0 (reserved) + counter 1 (auth) + data counters start at 2
        blockOffset += 2;

        // Bytes 12-15: Block counter within frame (4 bytes, big-endian)
        frameIV[12] = (byte) (blockOffset >>> 24);
        frameIV[13] = (byte) (blockOffset >>> 16);
        frameIV[14] = (byte) (blockOffset >>> 8);
        frameIV[15] = (byte) blockOffset;
        
        return frameIV;
    }

    private static byte[] deriveAndStoreInFooter(byte[] directoryKey, byte[] messageId, int frameNumber, 
                                                  org.opensearch.index.store.footer.EncryptionFooter footer) {
        String frameContext = EncryptionMetadataTrailer.FRAME_CONTEXT_PREFIX + frameNumber;
        byte[] frameBaseIV = HkdfKeyDerivation.deriveKey(directoryKey, messageId, frameContext, 16);
        footer.putFrameIV(frameNumber, frameBaseIV);
        return frameBaseIV;
    }


    /**
     * Calculate which frame contains a given file offset
     */
    public static int getFrameNumber(long fileOffset) {
        return (int) (fileOffset >>> 36);
    }

    /**
     * Calculate offset within a frame
     */
    public static long getOffsetWithinFrame(long fileOffset) {
        return fileOffset & 0xFFFFFFFFFFL;
    }
}
